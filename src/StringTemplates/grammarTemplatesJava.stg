delimiters "<",">"

Info() ::= <<
 This file contains all templates for the ProcessJ JVM compiler based on the grammar
 The CodeGeneratorJava.java visitor then uses these rules to generate Java code
 from ProcessJ source.
>>

Compilation(packageName, classname, typeDecls) ::= <<
<! package Generated<if(packageName)>.<packageName><endif>; !>
<! package <packageName>; !>
import java.util.*;
import ProcessJ.runtime.*;

public class <packageName> {
	<typeDecls;
 		separator ="\n">
}
>>

AltStat(name, chosen, caseCount, altSwitchGroup, timers, initBoolGuards, initGuards, jmp1, jmp2, timerKills, altCnt) ::= <<
<name> = new PJAlt(<caseCount>, this);	
<timers>
<initGuards>
<initBoolGuards>

boolean bRet<altCnt> = <name>.setGuards(boolGuards<altCnt>, guards<altCnt>);

if (!bRet<altCnt>) {
	System.out.println("RuntimeException: One of the boolean guards needs to be true!!");
	System.exit(1);
}

label(<jmp1>);	

<chosen> = <name>.getReadyGuardIndex();
<if(altSwitchGroup)><altSwitchGroup><endif>

if (<chosen> == -1) {
	this.runLabel = <jmp1>;
	yield();	
} else {
	<if(timerKills)><timerKills; separator=";\n"><endif>
	this.runLabel = <jmp2>;
	yield();
}

label(<jmp2>)
>>

AltSwitchGroup(cases, chosen) ::= <<
<if(cases)>
switch(<chosen>) {
	<cases; separator=";\n">;
}
<endif>
>>

AltCase(number, statementList) ::= <<
case <number>: 
  	<if(statementList)><statementList; separator = ";\n">;<endif>
	break
>>

AltBooleanGuardsArr(tempExprs, constants, altCnt) ::= <<
<if(tempExprs)><tempExprs; separator=";\n">;<endif>
<if(constants)>boolean[] boolGuards<altCnt> = {<constants; separator=", ">};<endif>	
>>

AltGuardsArr(guards, altCnt) ::= <<
<if(guards)>Object[] guards<altCnt> = {<guards; separator=", ">};<endif>
>>

AltTimerKill(timer) ::= <<
<if(timer)>
if (<timer>.started && !<timer>.expired) {
	<timer>.kill();
}	
<endif>
>>

AltTimerStart(timer) ::= <<
<if(timer)>	
if (!<timer>.started) {
	try {
		<timer>.start();
	} catch (InterruptedException e) {
		System.out.println("InterruptedException!");
	}
}
<endif>
>>

Assignment(left, right, op) ::= "<left> <op> <right>"

BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"

BreakStat() ::= "break"

CastExpr(ct, expr) ::= "(<ct>) (<expr>)"

ChannelWriteStat(channel, expr, jmp0, jmp1, shared) ::= <<

<!switch(runLabel) {
	case <jmp0>: resume(<jmp0>); break;
	case <jmp1>: resume(<jmp1>); break;
}!>

label(<jmp0>);
if (<channel>.isReadyToWrite()) {
	<channel>.write(this, <expr>);
	this.runLabel = <jmp1>;
	yield();
} else {
	<if(shared)><channel>.addWriter(this);<endif>
	setNotReady();
	this.runLabel = <jmp0>;
	yield();
}
label(<jmp1>)
>>

ChannelReadExpr(left, channel, alt, jmp0, jmp1) ::= <<
<if(alt)>
<left> = <channel>.read(this);
<else>
label(<jmp0>);
if(<channel>.isReadyToRead(this)) {
<if(left)>
	<left> = <channel>.read(this);
<else>
	<channel>.read(this);
<endif>
	this.runLabel = <jmp1>;
	yield();
} else {
	setNotReady();
	<channel>.addReader(this);
	this.runLabel = <jmp0>;
	yield();
}
label(<jmp1>)<\\>
<endif>
>>

ChannelReadExprExtRv(left, channel, alt, extRv, jmp0, jmp1) ::= <<
<if(alt)>
<left> = <channel>.readPreRendezvous(this);
<extRv; separator=";\n">
<channel>.readPostRendezvous(this);
<else>
label(<jmp0>);
if(<channel>.isReadyToRead(this)) {
<if(left)>
	<left> = <channel>.readPreRendezvous(this);
	<extRv; separator=";\n">;
	<channel>.readPostRendezvous(this);
<else>
	<channel>.readPreRendezvous(this);
	<extRv; separator=";\n">;
	<channel>.readPostRendezvous(this);
<endif>
	this.runLabel = <jmp1>;
	yield();
} else {
	setNotReady();
	<channel>.addReader(this);
	this.runLabel = <jmp0>;
	yield();
}
label(<jmp1>)<\\>
<endif>
>>

ConstantDecl(type, var) ::= "public static final <type> <var>;"

ClaimStat(stats, chanNameToReadEndType, ldstr, jmp) ::= <<
<if(ldstr)><ldstr; separator=";\n">;<endif>
label(<jmp>);
<if(chanNameToReadEndType.keys)>
if(<chanNameToReadEndType.keys, chanNameToReadEndType.values: { k, v | <if(v)>!<k>.claimReadingEnd()<else>!<k>.claimWritingEnd()<endif>}; separator=" || ">) {
	this.runLabel = <jmp>;
	yield();
}
<endif>
<stats; separator=";\n">;
<chanNameToReadEndType.keys, chanNameToReadEndType.values: { k, v | <if(v)><k>.unclaimReadingEnd()<else><k>.unclaimWritingEnd()<endif>}; separator=";\n">
>>

TimerReadExpr(left) ::= "<left> = PJTimer.read()"

ContinueStat() ::= "continue"

DoStat(stat, expr) ::= <<
do {
  <stat; separator = ";\n">;
} while( <expr> )
>>

ForStat(init, expr, incr, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>

GetTrue() ::= <<
public static boolean getTrue() {
	return true;
}
>>

ParForStat(parName, init, expr, incr, barriers, stats, jmp) ::= <<
final PJPar <parName> = new PJPar(-1, this);
int cnt = 0;	
List\<PJProcess> pp = new LinkedList\<PJProcess>(); 

for(<init; separator = ",">; <expr>; <incr>){
	cnt++;
	pp.add(
		<stats; separator=";\n">
	);
}
//set the process count	
<parName>.setProcessCount(cnt);
<if(barriers)><barriers:{b | <b>.enroll(cnt)}; separator = ";\n">;<endif>

//schedule all the processes
for(PJProcess p : pp) {
	p.schedule();
}
setNotReady();
this.runLabel = <jmp>;
yield();
label(<jmp>)
>>

IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>

InvocationNormal(qualifiedProc, procParams, isProcess, par, parfor, parName, barriers) ::= <<
<if(isProcess)>
<if(par)>
(new <qualifiedProc>(<if(procParams)> <procParams; separator =", "> <endif>){
  public void finalize() {
    <parName>.decrement();    
	<if(barriers)><barriers:{b | <b>.resign()}; separator = ";\n">;<endif>
  }
}).schedule()<\\>
<elseif(parfor)>
(new <qualifiedProc>(<if(procParams)> <procParams; separator =", "> <endif>){
  public void finalize() {
    <parName>.decrement();    
	<if(barriers)><barriers:{b | <b>.resign()}; separator = ";\n">;<endif>
  }
})<\\>
<endif>
<else>
<qualifiedProc>(<if(procParams)> <procParams; separator =", "> <endif>)<\\>
<endif>
>>

InvocationWithInvocationParamType(left, right, paramBlocks) ::= <<
<if(paramBlocks)><paramBlocks; separator=";\n\n">;<endif>
<if(left)><left>=<endif><right>
>>

LocalDeclNormalProc(typeStr, var, isChanType, isProtoType, isRecType, isBarrierType, isTimerType, notInitialized) ::= <<
<if(isChanType)>
<typeStr> <var><if(notInitialized)> = new <typeStr>()<endif><\\>
<elseif(isProtoType)>
PJProtocolCase <var><if(notInitialized)> = null<endif><\\>
<elseif(isRecType)>
<typeStr> <var><if(notInitialized)> = null<endif><\\>
<elseif(isBarrierType)>
<typeStr> <var><if(notInitialized)> = new PJBarrier()<endif><\\>
<elseif(isTimerType)>
<! Initialization handled by TimeoutStat. We still want LocalDecl to take care of creating fields. !>
<else>
<typeStr> <var><\\>
<endif>
>>

LocalDeclYieldingProc(typeStr, var, isChanType, isProtoType, isRecType, isBarrierType, isTimerType, notInitialized) ::= <<
<if(isChanType)>
<var><if(notInitialized)> = new <typeStr>()<endif><\\>
<elseif(isProtoType || isRecType)>
<var><if(notInitialized)> = null<endif><\\>
<elseif(isBarrierType)>
<var><if(notInitialized)> = new PJBarrier()<endif><\\>
<elseif(isTimerType)>
<! Initialization handled by TimeoutStat. We still want LocalDecl to take care of creating fields. !>
<else>
<if(!notInitialized)><var><endif><\\>
<endif>
>>

NewArray(left, type, dims) ::= <<
<left> = new <type><dims:{d | [<d>]}; separator = "">
>>

NewArrayIntializedElements(left, type, dims) ::= <<
<left> = (<type>[])new Object[<dims>];
for(int i=0; i \< <dims>; i++) {
	<left>[i] = new <type>();
}
>>

ParamDecl(type, name) ::= "<type> <name>"

AnonymousProcess(lookupswitch, body, parName, parfor, barriers) ::= <<
new PJProcess(){
	@Override
	public synchronized void run() {
		<lookupswitch>
		<if(body)><body; separator = ";\n">;<endif>
      	terminate();
	}
	
	@Override
	public void finalize() {
		<if(parName)><parName>.decrement();<endif>	
		<if(barriers)><barriers:{b | <b>.resign()}; separator = ";\n">;<endif>
	}
}<if(!parfor)>.schedule()<endif>
>>

ProcTypeDeclToProcess(modifiers, returnType, retstatFound, packageName, name, formals, formalNames, globals, implement, lookupswitch, body, mainMethod, foreverloop) ::= <<
public static class <name> extends PJProcess {
	<if(formals)><formals; separator = ";\n">;<endif>
	<if(globals)><globals; separator = ";\n">;<endif>

    <!modifiers><returnType> <name>(<\\!>
    public <name>(<\\>
    	<if(formals)><formals; separator = ", "><endif>) {
    	<if(formalNames)><formalNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
    }

	@Override
	public synchronized void run() {
		<lookupswitch>
		<body; separator = ";\n">;
		<if(!retstatFound && !foreverloop)>terminate();<endif>
	}
}

<if(mainMethod)><mainMethod><endif>
>>

ProcTypeDeclToMain(qualifiedProc) ::= <<
public static void main(String[] args) {
	Scheduler scheduler = new Scheduler();
	PJProcess.scheduler = scheduler;
	(new <qualifiedProc>(args)).schedule();
	PJProcess.scheduler.start();
}
>>
			
ProcTypeDeclToMethod(modifiers, returnType, retstatFound, packageName, name, formals, formalNames, globals, implement, body, last, foreverloop, lookupswitch) ::= <<

public static <returnType> <name>(<if(formals)><formals; separator = ", "><endif>) {
	<body; separator = ";\n">;
}
>>

ProtocolLiteral(protocolName, tagName, params) ::= <<
new <protocolName>.<tagName>(<if(params)><params; separator=", "><endif>)
>>

ProtocolCase(name, recMems, recMemNames, tag) ::= <<
public static class <name> extends PJProtocolCase {
	<if(recMems)><recMems:{n | public <n>}; separator=";\n">;<endif>
	public <name>(<if(recMems)><recMems; separator=", "><endif>) {
    	<if(recMemNames)><recMemNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
    	this.tag = "<tag>";
	}
}
>>

ProtocolTypeDecl(name, cases) ::= <<
public static class <name>{
	<cases; separator = "\n">
}
>>

RecordTypeDecl(name, recMems, recMemNames) ::= <<
public static class <name> {
	<if(recMems)><recMems:{n | public <n>}; separator=";\n">;<endif>
	public <name>(<if(recMems)><recMems; separator=", "><endif>) {
    	<if(recMemNames)><recMemNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
	}
}
>>

RecordMember(type, name) ::= "<type> <name>"

ProtocolAccess(protocolName, caseName, record, field) ::= "((<protocolName>.<caseName>) <record>).<field>"
RecordAccess(record, field) ::= "<record>.<field>"

RecordLiteral(name, params) ::= <<
new <name>(<if(params)><params; separator=", "><endif>)
>>

LookupSwitchTable(cases) ::= <<
<if(cases)>
switch(this.runLabel) {
	case 0: break;
    <cases; separator = ";\n">;
}<endif>
>>

LookupSwitchCase(caseNum) ::= <<
case <caseNum>: resume(<caseNum>); break
>>

ProcParam(parWsName, index, paramNumber, param) ::= <<
ProcParam(<parWsName>[<index>], <paramNumber>, <param>)
>>


ProcGetParam(type, name, number) ::= <<
<type> <name> = ProcGetParam(<number>, <type>)
>>

ParBlock(parCnt, parName, stats, barriers, jmp) ::= <<
final PJPar <parName> = new PJPar(<parCnt>, this);
<if(barriers)><barriers:{b | <b>.enroll(<parCnt>)}; separator = ";\n">;<endif>
	
<stats; separator=";\n\n">;
	
setNotReady();
this.runLabel = <jmp>;
yield();
label(<jmp>)
>>

ReturnStat(expr, procYields) ::= <<
<if (procYields)>
terminate();
return<\\>
<else>
return<if(expr)> <expr><endif><\\>
<endif>
>>

SwitchLabel(constExpr, defaultExpr) ::= <<
<if(constExpr)>case <constExpr><endif><if(defaultExpr)><defaultExpr><endif>:
>>

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, isProtocolExpr, switchGroups) ::= <<
<if(isProtocolExpr)>
switch( <expr>.tag ){
<else>
switch( <expr> ){
<endif>
  <switchGroups; separator = "\n">
}
>>

SyncStat(barrier, jmp) ::= <<
<barrier>.sync(this);
this.runLabel = <jmp>;
yield();
label(<jmp>)
>>

Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"

TimeoutStat(alt, name, delay, jmp) ::= <<
<name> = new PJTimer(this, <delay>);
<if(!alt)>
try {
		<name>.start();
		setNotReady();
		this.runLabel = <jmp>;
		this._pd$seed = 0L;
	yield();
} catch (InterruptedException e) {
	System.out.println("PJTimer Interrupted Exception!");
}
label(<jmp>)<\\>
<endif>
>>

UnaryPostExpr(expr, op) ::= "<expr><op>"

UnaryPreExpr(expr, op) ::= "<op><expr>"

Var(name, init) ::= "<if(name)><name><endif><if(name && init)> = <endif><if(init)><init><endif>"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>