Info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorC.java file then uses these rules as well as a visitor
 to generate our C equivalent code.
>>


Compilation(pragmas, packageName, imports, typeDecls, prototypes, parPrototypes,
  parProcs, functionToCall, stackSize, hasArray, globalWsName) ::= <<
<! TODO pragmas, packageName, imports !>
#include \<stdio.h>
#include \<cif.h>
#include \<stdbool.h>
#include \<string.h>

<CommentBar()>
<if(hasArray)>
<ArrayStruct()>
<CommentBar()>
<endif>

<ConcatFunction(globalWsName)>

<CommentBar()>
<if(prototypes)><prototypes; separator = ";\n">;<endif>
<if(parPrototypes)><\\>
<CommentBar()>
/*These functions were auto-generated by the compiler for par declarations or recursion: */
<parPrototypes; separator = ";\n">;
<endif>
<CommentBar()>
<CMainFunction(functionToCall, stackSize)>
<CommentBar()>
<typeDecls;
 separator ="\n/*========================================================================================*/\n">
<! These are the actual functions generated by our ParBlock !>
<if(parProcs)><\\>
<CommentBar()>
/*These functions were auto-generated by the compiler from par declarations: */
<CommentBar()>
<parProcs;
 separator ="\n/*========================================================================================*/\n">
<CommentBar()>
<endif>
>>


Assignment(left, right, op) ::= <<
(<left> <op> <right>)
>>


BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"


BreakStat() ::= "break"


ChannelWriteStat(globalWsName, channel, expr) ::= <<
ChanOutInt(<globalWsName>, <channel>, <expr>)
>>


ChannelReadExprInt(globalWsName, channel) ::= <<
({ int tempReadVar;
   ChanInInt(<globalWsName>, <channel>, &tempReadVar);
   tempReadVar;
})
>>


ChannelReadExprTimer(globalWsName, channel) ::= <<
TimerRead(<globalWsName>)
>>


TimeoutStat(globalWsName, delay) ::= <<
TimerDelay(<globalWsName>, <delay>)
>>


CastExpr(ct, expr) ::= "((<ct>) <expr>)"


ContinueStat() ::= "continue"


DoStat(stat, expr) ::= <<
do{
  <stat; separator = ";\n">;
}while( <expr> )
>>


IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>


Invocation(functionName, paramNumber, workspace, procParams) ::= <<
<functionName>(<workspace><if(procParams)>, <procParams; separator =", "><endif>)
>>


InvocationPar(wordName, paramNumber, stackSize, parWs, index, globalWsName, procParams) ::= <<
word <wordName>[WORKSPACE_SIZE(<paramNumber>, <stackSize>)];
<parWs>[<index>] = LightProcInit(<globalWsName>, <wordName>, <paramNumber>, <stackSize>);
<if(procParams)><procParams; separator = ";\n">;<endif>
>>


ProcPar(paramWorkspaceName, processNumber, list) ::= <<
<! list is a list of strings alternating between the workspace form process n and the
   name of process n. Ex: { "ws1", "source", "ws2", "writer", "ws3", "doubleValue",... !>


ProcPar(<paramWorkspaceName>, <processNumber>, <list; separator = ", ">);
>>


ForStat(init, expr, incr, barriers, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>

ParForStat(workspace, function, init, expr, incr, stackSize, procParams, paramNumbers,
           barrierInits) ::= <<
<! <function> is the function to run in parallel. !>
{
  LightProcBarrier __barrier;
  unsigned long __numberOfProcesses = 0;

  /* We iterate over the predicate to know the total number of processes to allocate.
   Warning! It is slow and will fail horribly if the for loop has side effects.*/
  for(<init; separator = ",">; <expr>; <incr>)
    __numberOfProcesses++;

  <if(barrierInits)>
  /*Initialize our barriers. */
  <barrierInits; separator = ";\n">;
  <endif>

  /* Every function requires a Workspace to run and a word pointer.*/
  Workspace* __functionWsArray = MAlloc(WP, sizeof(Workspace) * __numberOfProcesses);
  word** __wordWsArray = MAlloc(WP, sizeof(word*) * __numberOfProcesses);

  LightProcBarrierInit(<workspace>, &__barrier, __numberOfProcesses);
  /*We need our own iterator to allocate all processes. */
  unsigned long __i = 0;

  for(<init; separator = ",">; <expr>; <incr>){
    /*Allocate words needed for function to run and init process. */
    __wordWsArray[__i] = (word*) MAlloc(WP, sizeof(word) * WORKSPACE_SIZE(<paramNumbers>, <stackSize>));
    __functionWsArray[__i] = LightProcInit(WP, __wordWsArray[__i], <paramNumbers>, <stackSize>);
    <if(procParams)>
    /*Parameters for our loop. */
    <procParams; separator = ";\n">;
    <endif>
    /*Run process!*/
    LightProcStart(<workspace>, &__barrier, __functionWsArray[__i], <function>);
    __i++;
  }

  LightProcBarrierWait(<workspace>, &__barrier);

  /*Free memory we allocated!*/
  for(__i = 0; __i \< __numberOfProcesses; __i++)
    MRelease(<workspace>, __wordWsArray[__i]);
  MRelease(<workspace>, __functionWsArray);
  MRelease(<workspace>, __wordWsArray);
}
>>


ReturnStat(expr) ::= "return<if(expr)> <expr><endif>"

ParBlock(stringStats, procPar, wsArrayName, wsArraySize, barrierInits) ::= <<
<if(barrierInits)>
/*Initialize our barriers. */
<barrierInits; separator = ";\n">;
<endif>

/*Parallel Block*/
{
  Workspace <wsArrayName>[<wsArraySize>];
  <stringStats; separator = "\n\n">
  <procPar>
}
>>


ProcTypeDecl(modifiers, returnType, name, formals, implement, body, workspace, last) ::= <<
<modifiers><returnType> <name>(Workspace <workspace><\\>
  <if(formals)>, <formals; separator = ", "><endif>)<implement>{
  <body; separator = ";\n">;<\\>

  <if(last)>

  shutDownLabel:
    Shutdown(<workspace>);<endif>
  <!TODO return type !>

}
>>

ParBlockProc(name, body, paramWorkspaceName, getParameters, return) ::= <<
<! Very similar to ProcTypeDecl but simplified for ParBlocks only. !>
void <name>(Workspace <paramWorkspaceName>){
  <if(getParameters)><getParameters; separator = ";\n">;<endif>
  <if(return)>*<return> = <body; separator = ";\n">;<else><body; separator = ";\n">;<endif>

  return;
}
>>


LocalDecl(type, var, constant, channelPart) ::= <<
<! If this is channel it must be initialized! !>
<type> <var><if(channelPart)>MyChannel, *<var> = &<var>MyChannel; <channelPart><endif>
>>


SwitchLabel(constExpr) ::= "case <constExpr>:"

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, switchGroups) ::= <<
switch( <expr> ){
  <switchGroups; separator = "\n">
}
>>


Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"


UnaryPostExpr(expr, op) ::= "((<expr>) <op>)"


UnaryPreExpr(expr, op) ::= "(<op> (<expr>))"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>


Var(name, init) ::= "<name><if(init)> = <init><endif>"


CommentBar() ::= "/*======================================================================================*/"

ArrayStruct() ::= <<
typedef struct {
  void* array;
  int* dimensions;
  int numDim;
} ArrayStruct;
>>


ConcatFunction(globalWsName) ::= <<
char* __concatStrings(Workspace <globalWsName>, char* s1, char* s2) {
    char* temp = (char*) MAlloc(<globalWsName>, sizeof(char) * (strlen(s1) + strlen(s2) + 1));
    ExternalCallN(strcpy, 2, temp, "");
    ExternalCallN(strcat, 2, temp, s1);
    ExternalCallN(strcat, 2, temp, s2);
    return temp;
}
>>


CMainFunction(functionToCall, stackSize) ::= <<
int main(int argc, char** argv){
  int ccspResults;
  Workspace ws;

  /*Initialize CCSP*/
  ccspResults = ccsp_init();
  if(!ccspResults){
    printf("Error starting CCSP, exiting...\n");
    return 1;
  }

  ws = ProcAllocInitial(0, <stackSize>);
  ProcStartInitial(ws, <functionToCall>);
  return 0;
}
>>


Prototype(type, name, formals, workspace) ::= <<
<type> <name>(Workspace <workspace><if(formals)>, <formals; separator = ", "><endif>)
>>


ExternPrint(string, argumentList, argumentCount) ::= <<
ExternalCallN(printf, <argumentCount>, "<string>"<if(argumentList)>, <argumentList; separator = ", "><endif>)
>>


ProcParam(globalWsName, parWsName, index, paramNumber, param) ::= <<
ProcParam(<globalWsName>, <parWsName><index>, <paramNumber>, <param>)
>>


ProcGetParam(type, name, number, globalWsName) ::= <<
<type> <name> = ProcGetParam(<globalWsName>, <number>, <type>)
>>


ChanInit(globalWsName, channelName) ::= "ChanInit(<globalWsName>, <channelName>)"


CompoundStatement(param) ::= "<param>"


AltStat(altType, enableChannelList, waitType, disableChannelList,
        switchStatement) ::= <<
<! This is the main statement to create our AltCase, we have auxillary functions
   to fill the rest of it in... !>
/*Start of Alternative!*/
<altType>;

<enableChannelList; separator = ";\n">;

/*Do waiting here! */
<waitType>;

<disableChannelList; separator = ";\n">;

<switchStatement>

/*End of Alternative!*/
>>

NormalAltType(globalWsName) ::= "Alt(<globalWsName>)"
TimerAltType(globalWsName) ::= "TimerAlt(<globalWsName>)"


NormalWaitType(globalWsName) ::= "AltWait(<globalWsName>)"
TimerWaitType(globalWsName) ::= "TimerAltWait(<globalWsName>)"


AltEnableTimeout(globalWsName, number, time, name) ::= <<
<! This statement is funny as we actually need a variable to hold our time. !>
<name> = TimerRead(<globalWsName>) + <time>;
AltEnableTimer(<globalWsName>, <number>, <name>)
>>


AltEnableSkip(globalWsName, number) ::= "AltEnableSkip(<globalWsName>, <number>)"
AltEnableChannel(globalWsName, number, name) ::= "AltEnableChannel(<globalWsName>, <number>, <name>)"


AltDisableTimeout(globalWsName, number, name) ::= <<
AltDisableTimer(<globalWsName>, <number>, <name>)
>>


AltDisableChannel(globalWsName, number, name) ::= "AltDisableChannel(<globalWsName>, <number>, <name>)"
AltDisableSkip(globalWsName, number) ::= "AltDisableSkip(<globalWsName>, <number>)"


AltSwitch(altEnd, caseList) ::= <<
<! Our Switch Statement is a list of cases separated by breaks. !>
switch( <altEnd> ){
  <caseList; separator ="\n">
  default:
    printf("Reached default case of switch statement from Alt\n");
    printf("This should never happen... dying now X(\n");
    exit(1);
}
>>

AltCase(number, guardToDo, statementList) ::= <<
case <number>:
  <guardToDo>;
  <statementList; separator = ";\n">;
  break;
>>


AltEnd(globalWsName) ::= "AltEnd( <globalWsName> )"

LocalDeclArray(globalWsName, name, expr) ::= <<
ArrayStruct* <name> = (ArrayStruct*) MAlloc(<globalWsName>, sizeof(ArrayStruct))<if(expr)>;
<expr><endif>
>>

SetArrayDimensions(name, num, expr) ::= "<name>->dimensions[<num>] = <expr>"

SetArraySize(name, size) ::= "<name>->numDim = <size>"

NewArray(globalWsName, name, type, numDim, size, dimensionList) ::= <<
<name>->array = (void*) MAlloc(<globalWsName>, (sizeof(<type>) * <size>));
<name>->numDim = <numDim>;
<name>->dimensions = (int*) MAlloc(<globalWsName>, (sizeof(int) * <numDim>));
<dimensionList; separator = ";\n">
>>


ArrayAccess(name, index, dim) ::= "(<index> * <name>->dimensions[<name>->numDim - 1 - <dim>])"


StringLiteral(globalWsName, string, flag, var) ::= <<
<if(flag)>char* <endif><var> = (char*) MAlloc(<globalWsName>, sizeof(char) * (strlen(<string>) + 1));
ExternalCallN(strcpy, 2, <var>, <string>)
>>


StringCat(globalWsName, s1, s2) ::= "__concatStrings(<globalWsName>, <s1>, <s2>)"


ParamDecl(type, name) ::= "<type> <name>"


RecordAccess(name, field) ::= "<name>-><field>"


RecordDecl(id, memberList) ::= <<
typedef struct {
    <memberList; separator = ";\n">;
} <id>;
>>


LocalNamedType(globalWsName, name, type) ::= "<type>* <name> = (<type>*) MAlloc(<globalWsName>, sizeof(<type>))"


RecordMember() ::= ""


RecordLiteral() ::= ""


ParamDecl(type, name) ::= "<type> <name>"


WriteChannelMacro() ::= <<
#define WRITECHANNEL(functionName, type, expr, size) \\
void functionName(Workspace WP){ \\
  Channel** c = ProcGetParam(WP, 0, Channel**); \\
  type temp = (expr); \\
  ChanOut(WP, *c, &temp, size); \\
  return; \\
}
>>


ReadChannelMacro() ::= <<
#define READCHANNEL(functionName, type, size) \\
void functionName(Workspace WP){ \\
  type* x = ProcGetParam(WP, 0, type*); \\
  Channel** c = ProcGetParam(WP, 1, Channel**); \\
  ((*x) = ({ type tempX; \\
     ChanIn(WP, (*c), &tempX, size); \\
     tempX; \\
  })); \\
  return; \\
}
>>


writeChannel(functionName, type, expr, size) ::= <<
WRITECHANNEL(<functionName>, <type>, <expr>, <size>)
>>


readChannel(functionName, type, size) ::= <<
READCHANNEL(<functionName>, <type>, <size>)
>>


nestedBlock(array) ::= <<
{
  <array; separator = ";\n">;
}
>>


SyncStat(globalWsName, barrierName) ::= <<
LightProcBarrierWait(<globalWsName>, &<barrierName>)
>>


ForEnroll(globalWsName, barrierName, n) ::= <<
LightProcBarrierInit(<globalWsName>, &<barrierName>, <n>)
>>


Recursion(globalWsName, paramNumber, stackSize, functionName, wsName, procParams, returnType) ::=<<
/*Recursive call to function. */
({
  <if(returnType)>
  /*Variable to hold the return for statement expression.*/
  <returnType> __return;
  <endif>
  LightProcBarrier __barrier;
  /*Single process running. */
  int __one = 1;
  LightProcBarrierInit(<globalWsName>, &__barrier, __one);
  
  word* __wordWs = (word*) MAlloc(WP, sizeof(word) * WORKSPACE_SIZE(<paramNumber>, <stackSize>));
  Workspace <wsName> = LightProcInit(<globalWsName>, __wordWs, <paramNumber>, <stackSize>);
  <if(procParams)><procParams; separator = ";\n">;<endif>

  LightProcStart(<globalWsName>, &__barrier, <wsName>, <functionName>);
  LightProcBarrierWait(<globalWsName>, &__barrier);
  MRelease(<globalWsName>, __wordWs);
  <if(returnType)>
  __return;
  <else>
  NULL;
  <endif>
})
>>
